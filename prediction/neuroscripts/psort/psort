#!/usr/bin/perl -w

################################################################
## PSORT II:  main routine
##                         version: 981201
##          copyright: Kenta Nakai & Paul Horton, 1996-1998
##
## 980530: variable ncn added
## 980602: variable lps added
## 980605: "two-fold" kNN
## 981111: bug fix for sequence-handling
## 981201: first official version
#################################################################

#  ----------- Disclaimer and licensing thing--------------------
# Please send comments, bug reports, or bug fixes to:
#     nakai@imcb.osaka-u.ac.jp

#     The source code of this program is free software;
#     you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#     However, the attached sequence data ('all.seq') does not obey the
#     above policy.  It is an excerpt of SWISS-PROT, which is not free
#     for non-academic users.  
#     See the content of 'all.seq' for more details.

#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.

#     If you want a copy of the GNU General Public License type
#     cntl-h cntl-c from emacs.
#     or write to the Free Software Foundation, Inc., 675 Mass Ave, 
#     Cambridge, MA 02139, USA.

# --------------------------------------------------------------------
# Usages:
#     psort -t training_file_name    for creating DBM files
#     psort (-v) testing_file_name   for prediction (-v: verbose mode)
#     psort -t training_file (-v) testing_file    is also possible
#     psort -w testing_file_name     (-w: used in the WWW server)

# --------------------------------------------------------------------
# Program files: psort, sub1.pl, sub2.pl, sub3.pl
#
# DBM files created by the '-t' option:
#   attribute.(dir/pag), range.(dir/pag), locat.(dir/pag)

#   N.B.: In its original distribution, these files were created
#         by the information from the SWISS-PROT database

# --------------------------------------------------------------------
# Input File format:
#    The format of both the training sequence file and the
#    testing sequence file should be the FASTA (Pearson) format.
#    In the training file, a one-word label for the localization
#    information of each sequence should be written as the
#    second word of its title line, e.g.:
#    >P00001  nuc  this is a sample sequence
#    
#    Lines beginning with the character '#' will be skipped

# --------------------------------------------------------------------
# Global variables:
#    $id         sequence id
#    $seq        sequence
#    $leng       length of seq
#    @seq        array version of seq; split(//,@seq)
#    $OPT_V      flag for the verbose option
#
#    $loc        label for the localization site
#    $desc       description of each test seq, if any
#
#    @variable_names
#    %loc_info

# Global DBM variables:
#    %ATTRIB     { seq_id }{ var_name } = var_value
#    %RANGE      { var_name }{ min/max } = min/max_value
#    %LOCAT      { seq_id } = loc_label
#

# --------------------------------------------------------------------

$HOMEDIR = "." unless ($HOMEDIR) = $0 =~ /^(.+)\/psort/;

require "$HOMEDIR/sub1.pl";
require "$HOMEDIR/sub2.pl";
require "$HOMEDIR/sub3.pl";

#########################################
#$K_VALUE = 23;   ##
$K_VALUE1 = 9;   ## parameter for kNN 
$K_VALUE2 = 23;  ##  parameter for kNN
#########################################

## treat options #################################################

$OPT_V = 0;  ## default is not the verbose mode
$OPT_T = 0;  ## default is not the training mode
$OPT_W = 0;  ## default is not the www mode

while ($_ = shift) {
    if( /^-v$/) {
	$OPT_V = 1; # true
    } elsif(/^-w$/) {
	$OPT_W = $OPT_V = 1; # true for the verbose mode also
    } elsif(/^-t$/) {
	$OPT_T = 1; # true
	$train_file = shift;
    } else {
	$test_file = $_;
    }
}

## initialization

@variable_names = (
 'psg', 'gvh', 'alm', 'top', 'tms',
 'mit', 'mip', 'nuc', 'erl', 'erm',
 'pox', 'px2', 'vac', 'rnp', 'act',
 'caa', 'yqr', 'tyr', 'leu', 'gpi',
 'myr', 'dna', 'rib', 'bac',
 'm1a', 'm1b', 'm2',  'mNt', 'm3a', 'm3b', 'm_',
 'ncn', 'lps', 'len'
);

%loc_info = (
 'csk' =>  'cytoskeletal',
 'cyt' =>  'cytoplasmic',
 'nuc' =>  'nuclear',
 'mit' =>  'mitochondrial',
 'ves' =>  'vesicles of secretory system',
 'end' =>  'endoplasmic reticulum',
 'gol' =>  'Golgi',
 'vac' =>  'vacuolar',
 'pla' =>  'plasma membrane',
 'pox' =>  'peroxisomal',
 'exc' =>  'extracellular, including cell wall'
## from the original YPD classification, 'mem' and 'lip' were omitted
);

%small_group = (
 'csk' =>  1,
 'cyt' =>  0,
 'nuc' =>  0,
 'mit' =>  0,
 'ves' =>  1,
 'end' =>  1,
 'gol' =>  1,
 'vac' =>  1,
 'pla' =>  0,
 'pox' =>  1,
 'exc' =>  1
);

$seq = '' x 1000; 
@seq = ('') x 1000;
$big_num = 99999;

## processing the training data ###########################################

if($OPT_T) {
    open(TRAIN_SEQ, $train_file) || 
	die "can't open $train_file; Usage: psort -t training_seq_file\n";

    warn "Creating new data files..\n";
    unlink "$HOMEDIR/attribute.dir" if -e "$HOMEDIR/attribute.dir";
    unlink "$HOMEDIR/attribute.pag" if -e "$HOMEDIR/attribute.pag";
    unlink "$HOMEDIR/range.dir" if -e "$HOMEDIR/range.dir";
    unlink "$HOMEDIR/range.pag" if -e "$HOMEDIR/range.pag";
    unlink "$HOMEDIR/locat.dir" if -e "$HOMEDIR/locat.dir";
    unlink "$HOMEDIR/locat.pag" if -e "$HOMEDIR/locat.pag";

    dbmopen(%ATTRIB, "$HOMEDIR/attribute", 0666) || 
	die "can't create \"attribute\" DBM file\n";
    dbmopen(%RANGE, "$HOMEDIR/range", 0666) || 
	die "can't create \"range\" DBM file\n";
    dbmopen(%LOCAT, "$HOMEDIR/locat", 0666) || 
	die "can't create \"locat\" DBM file\n";

## initailize
    foreach (@variable_names) {
	$RANGE{$_, 'max'} = -$big_num;
	$RANGE{$_, 'min'} =  $big_num;
    }

## read and calculate

    $seq_count = 0;

    until(eof TRAIN_SEQ) {

	&getseq(TRAIN_SEQ, "train");

	if($leng < 21) {
	    warn "$id: too short length ($leng), skipped\n";
	    next;
	} elsif(defined $LOCAT{$id}) {
	    warn "$id entry name found twice in training file, skipped\n";
	    next;
	} elsif(defined $loc_info{$loc}) {
	    $LOCAT{$id} = $loc;  # define
	    $seq_count++;
	} else {
	    warn "$id skipped because its location, $loc, was ambiguous\n";
	    next;
	}
	printf STDERR "%s %s %4d\n", $id, $loc, $leng;

	%vars = &seqana;

	foreach (@variable_names) {
	    $ATTRIB{$id, $_} = $vars{$_};
	    $RANGE{$_, 'min'} = $vars{$_} if $RANGE{$_, 'min'} > $vars{$_};
	    $RANGE{$_, 'max'} = $vars{$_} if $RANGE{$_, 'max'} < $vars{$_};
	}
    }
    @seq = ();

## normalization
    warn "Normalizing the variables...\n";

    foreach $name (@variable_names) {
	die "big_num error for $name\n" if $RANGE{$name, 'min'} == $big_num;
	die "big_num error for $name\n" if $RANGE{$name, 'max'} == -$big_num;
	$range = $RANGE{$name, 'max'} - $RANGE{$name, 'min'};
	warn "Warning: variable $name has a range of zero\n" if $range == 0;

	while($seqid = (each %LOCAT)[0]) {
	    if($range > 0) {
#		print "$seqid $name ",$ATTRIB{$seqid, $name}, "\n";
		$ATTRIB{$seqid, $name} = 
		    ($ATTRIB{$seqid, $name} - $RANGE{$name, 'min'}) / $range;
	    } else {
		$ATTRIB{$seqid, $name} = 0;
	    }
	}
    }

    print STDERR "training processes done.  $seq_count sequences in total\n";

    close TRAIN_SEQ;
    dbmclose %ATTRIB unless defined $test_file;
    dbmclose %RANGE unless defined $test_file;
    dbmclose %LOCAT unless defined $test_file;

}

## processing the test file ###############################################

if(defined($test_file)) {
    open(TEST_SEQ, $test_file) || die "*** Can't open $test_file\n";
} else {
    exit;
}

unless(defined($train_file)) {
    unless(dbmopen(%ATTRIB, "$HOMEDIR/attribute", 0666)) {
	warn "** No attribute file. You must use the -t option, first\n";
	die "Usage: psort -t training_seq_file (-v) test_seq_file\n";
    }
    unless(dbmopen(%RANGE, "$HOMEDIR/range", 0666)) {
	warn "** No range file. You must use the -t option, first\n";
	die "Usage: psort -t training_seq_file (-v) test_seq_file\n";
    }
    unless(dbmopen(%LOCAT, "$HOMEDIR/locat", 0666)) {
	warn "** No range file. You must use the -t option, first\n";
	die "Usage: psort -t training_seq_file (-v) test_seq_file\n";
    }
}

@training_names = ();

while(($id, $loc) = each %LOCAT) {

    push(@training_names, $id);
    if(defined( $training_class_freq{ $loc } ) ) {
	++$training_class_freq{ $loc };
    } else {
	$training_class_freq{ $loc } = 1;
    }

}

## for WWW server

if($OPT_W) {
    print "Content-type: text/html\n\n";
    print "<TITLE> PSORT II server </TITLE>\n<HR>\n";
}

## sequence input

until(eof TEST_SEQ) {

    &getseq(TEST_SEQ, "test");

    if($leng < 21) {
	warn "$id: too short length ($leng), skipped\n";
	next;
    } elsif(defined $LOCAT{$id}) {
	warn "$id entry name is found in training file\n";
#	next;
    }

    unless($OPT_W) {
	print '-'x75, "\n";
    }
    if($OPT_V) {
	print "<H1>Input Sequence</H1>\n<PRE>\n" if $OPT_W;
	printf("%s (%d aa) %s\n\n", $id, $leng, $desc);
	&prettyprint($seq);
	print "\n";
	print "</PRE>\n<HR>\n\n" if $OPT_W;
    } else {
	print "$id\t$desc\n\n";
    }

    print "<H1>Results of Subprograms</H1>\n\n<PRE>\n" if $OPT_W;
    %vars = &seqana;
    print "</PRE>\n<HR>\n\n" if $OPT_W;

## normalization
    foreach (@variable_names) {
	$range = $RANGE{$_, 'max'} - $RANGE{$_, 'min'};
	die "$id: var $_ undefined\n" unless defined $vars{$_};
	if($range > 0) {
	    $vars{$_} = ($vars{$_} - $RANGE{$_, 'min'}) / $range;
	} else {
	    $vars{$_} = 0;
	}
    }

    $i = 0;
    unless($OPT_V) {
	foreach (@variable_names) {
	    printf " %-3s: %4.2f", $_, $vars{$_};
	    print ((++$i % 7 == 0) ? "\n" : " ");
	}
	print "\n\n";
    }

## kNN
    if($OPT_W) {
	print "<A HREF=\"/psort/helpwww2.html#note\"><H1>Results of the <i>k</i>-NN Prediction</H1></A>\n";
	print "<i>k</i> = $K_VALUE1/$K_VALUE2\n\n<PRE>\n";
    } elsif($OPT_V) {
	print '-'x75, "\n\nFinal Results (k = $K_VALUE1/$K_VALUE2):\n\n";
    }
    &knn ($K_VALUE1, $K_VALUE2, @vars);
    print "</PRE>\n<HR>\n" if $OPT_W;
}

close TEST_SEQ;
dbmclose %ATTRIB;
dbmclose %RANGE;
dbmclose %LOCAT;

#######################################################################
# main subroutines
#######################################################################

sub seqana {

    my($gvhpos, $npos, $middle, $sig, $mtype, $start, $end, $gmotif);
    my(%var);

    if($OPT_V && $seq[0] ne 'M') {
	print "*** Warning: 1st aa is not methyonine\n\n";
    } 

## signal peptide
    $var{psg} = &sub1::psg;

    ($var{gvh}, $gvhpos) = &sub1::gvh("eukaryote");

    if($var{psg} > 0 && $var{gvh} > -2.1) {
	$sig = 'cleavable';
	print ">>> Seems to have a cleavable signal peptide (1 to $gvhpos)\n\n"
			if $OPT_V;
    	($var{tms}, $var{alm}, $npos) = &sub1::alom2($gvhpos+1, 0.5, -2.0);
	$middle = int($gvhpos / 2);
    } else {
	$sig = 'nosignal';
	print 
	    ">>> Seems to have no N-terminal signal peptide\n\n" if $OPT_V;
    	($var{tms}, $var{alm}, $npos) = &sub1::alom2(1, 0.5, -2.0);
	$middle = $npos + 7;
    }

    if($var{psg} <= 0 && $var{tms} == 0) {
	$var{top} = 0;
    } else {
   	$var{top} = &sub1::mtop($middle);
	if($var{psg} > 0 && $var{top} > 0 && $OPT_V) {
	    print 
		">>>Caution: Inconsistent mtop result with signal peptide\n";
	}
    }

    ($mtype, $start, $end) = &sub1::mtype_assign($var{tms}, $sig, $var{top});
    die "$id: inconsistent ($mtype) $start : $end\n" unless $start <= $end;

    $var{gpi} = 0;
    if($var{tms} > 0) {
	print ">>> membrane topology: type $mtype" if $OPT_V;
	if($mtype eq '3a' || $mtype eq '3b') {
	    print "\n\n" if $OPT_V;
	} else {
	    print "  (cytoplasmic tail $start to $end)\n\n" if $OPT_V; 
	    if($mtype eq '1a' && ($end-$start < 10)) {
		print ">>> Seems to be GPI anchored\n\n" if $OPT_V;
		$var{gpi} = 1;
	    }
	}
    }

################################
    $var{mit} = &sub2::mitdisc;
    ($var{mip}, $gmotif) = &sub2::gavel;
    $var{nuc} = &sub2::nucdisc;
    $var{erl} = &sub2::hdel;
    $var{erm} = &sub2::erm($mtype);
    $var{pox} = &sub2::pts1;
    $var{px2} = &sub2::pts2;
    $var{vac} = &sub2::vaccalc;
    $var{rnp} = &sub2::rnp1;
    $var{act} = &sub2::actin;
    $var{myr} = &sub2::nmyr;
    $var{caa} = &sub2::isoprenyl;
    $var{yqr} = &sub2::yqrl($var{tms}, $start);
    $var{tyr} = &sub2::tyros($var{tms}, $start, $end);
    $var{leu} = &sub2::dileu($var{tms}, $start, $end);
################################
    $var{dna} = &sub3::dnabind;
    $var{rib} = &sub3::ribosomal;
    $var{bac} = &sub3::bactdna;
##   
    ($var{m1a}, $var{m1b}, $var{m2}, $var{mNt}, 
	 $var{m3a}, $var{m3b}, $var{m_})  = (0,0,0,0,0,0,0);

    if($mtype eq '1a') {$var{m1a} = 1;}
    elsif($mtype eq '1b') {$var{m1b} = 1;}
    elsif($mtype eq '2 ') {$var{m2} = 1;}
    elsif($mtype eq 'Nt') {$var{mNt} = 1;} 
    elsif($mtype eq '3a') {$var{m3a}= 1;} 
    elsif($mtype eq '3b') {$var{m3b}= 1;} 
    elsif($mtype eq '__') {$var{m_}= 1;} 
    else {die "*** undefined mtype value: $mtype\n";}

##########
    $var{ncn} = &sub1::areinha;
    $var{lps} = &sub2::lupas;
    $var{len} = $leng;
##########
#    unless($OPT_V) {
#	printf "%s\t%6.2f\t%6.2f\t%6.2f\t%6.2f\t%6d\n",
#	     $id, $var{psg}, $var{gvh}, $var{alm}, $var{top}, $var{tms};
#	printf "     \t%6.2f\t%6d\t%6.2f\t%6d\t%6d\n", 
#	     $var{mit}, $var{mip}, $var{nuc}, $var{erl}, $var{erm};
#	printf "     \t%6.2f\t%6d\t%6d\t%6d\t%6d\n", 
#	     $var{pox}, $var{px2}, $var{vac}, $var{rnp}, $var{act};
#	printf "     \t%6d\t%6d\t%6.2f\t%6d\t%6d\n", 
#	     $var{caa}, $var{yqr}, $var{tyr}, $var{leu}, $var{gpi};
#	printf "     \t%6d\t%6d\t%6d\t%6d\n", 
#	     $var{myr}, $var{dna}, $var{rib}, $var{bac};
#	printf "     \t%6d\t%6d\t%6d\t%6d\t%6d\t%6d\t%6d\n",
#    $var{m1a}, $var{m1b}, $var{m2}, $var{mNt}, $var{m3a}, $var{m3b}, $var{m_};
#    }

    %var;
}


###########################################
sub prettyprint {
    my($seq) = $_[0];
    my($i);
    my($times) = int(length($seq) / 10);
    if ($times > 0) {
	foreach $i (1..$times) {
	    print substr($seq, ($i-1)*10, 10);
	    ($i%5==0) ? print "\n" : print " ";
	}
    }
    print substr($seq, $times*10), "\n";
}

sub getseq {

    my($f_handle, $opt) = @_;
    die "** readseq: illegal option $opt" 
	unless ($opt =~ /train/i || $opt =~ /test/i);

    while(<$f_handle>) {
	next if /^\#/;
	die "?? not a FASTA format: $_" unless ($id) = /^>(\S+)/;
	if($opt =~ /train/i) {
	    die "The 2nd word should be the location label\n" 
		unless ($loc) = /^>\S+\s+(\w+)/;
	} else {
	    $desc = "" unless ($desc) = /^>\S+\s+(\w.+)/;
	}
	last;
    }

    $seq = "";

    while (<$f_handle>) {
	next if /^\#/;
	if(/^>/) {
	    seek($f_handle, -length($_), 1);
	    last;
	}
	chomp;
	$seq .= $_;
    }

    chop $seq if $seq =~ /\*$/;  ## stop codon
#    $seq =~ tr/ //d;
    $seq =~ tr/a-z/A-Z/;
    $seq =~ tr/ABCDEFGHIKLMNPQRSTVWXYZ//cd;

    $leng = length($seq);
    @seq = split(//, $seq);

    my($found) = 0;
    foreach (0..$leng-1) {
      if($seq[$_] eq 'X' || $seq[$_] eq 'B' || $seq[$_] eq 'Z') {
	warn("** $id: amino acid '$seq[$_]' changed to 'G'\n");
	$seq[$_] = 'G';
	$found = 1 if $found == 0;
      }
    }
    $seq =~ tr/BZX/G/ if $found == 1;

#    printf "%s %s %4d\n", $id, $loc, $leng  if $opt =~ /train/i;
}

# subroutines for kNN ###################################################

sub by_distance {
    ($distance_pair{ $a } <=> $distance_pair{ $b }) || 
	($training_class_freq{$LOCAT{ $a }} <=> 
	 $training_class_freq{$LOCAT{ $b }});  ## more common
}

sub knn {
    my($k1, $k2, @vars) = @_;
    my(%freq, $neighbor_class, @sorted_freq_key, @sorted_names);
#######
#    my(%weights) = (
#	    psg => 0.20, gvh => 0.35, alm => 0.34, top => 0.09, tms => 1.28,
#	    mit => 0.43, mip => 0.01, nuc => 0.13, erl => 0.06, erm => 0.17,
#	    pox => 0.30, px2 => 0.02, vac => 0.02, rnp => 0.005,act => 0.005,
#	    caa => 0.04, yqr => 0.81, tyr => 0.005,leu => 0.005,gpi => 0.13,
#	    myr => 0.005,dna => 0.04, rib => 0.10, bac => 0.01, m1a => 0.17,
#	    m1b => 0.04, m2  => 0.24, mNt => 0.07, m3a => 1.67, m3b => 0.43,
#	    m_  => 5.85, ncn => 4.35, lps => 1,
#    );

#####

# calculate distances
    foreach (@training_names) {
	my($distance) = 0;
	foreach $var (@variable_names) {
#	    $distance += $weights{$var} * 
	    $distance += 
		($ATTRIB{ $_ , $var } - $vars{$var}) ** 2;
	}
	$distance_pair {$_} = $distance;
    }

    @sorted_names = sort by_distance (@training_names);
##    @sorted_names = &simple_sort ($k);


##################################################################

# check neighbor classes
    foreach $i (0..$k1-1) {
	$neighbor_class = $LOCAT{ $sorted_names[$i] };

	if(defined( $freq{ $neighbor_class } ) ) {
	    ++$freq{ $neighbor_class };
	} else {
	    $freq{ $neighbor_class } = 1;
	}
    }

    @sorted_freq_key = sort {$freq{$b}<=>$freq{$a}} (keys %freq);

    my($K) = $k1; ## which of k1/k2 were used

   unless($small_group{$sorted_freq_key[0]}) {
	$K = $k2;
	foreach $i ($k1..$k2-1) {
	    $neighbor_class = $LOCAT{ $sorted_names[$i] };

	    if(defined( $freq{ $neighbor_class } ) ) {
		++$freq{ $neighbor_class };
	    } else {
		$freq{ $neighbor_class } = 1;
	    }
	}
	@sorted_freq_key = sort {$freq{$b}<=>$freq{$a}} (keys %freq);
    }

# print resuts
    foreach (@sorted_freq_key) {
	printf( "\t%5.1f %%: %s\n", $freq{$_}/$K*100, $loc_info{$_} );
    }
    print "\n>> prediction for $id is $sorted_freq_key[0] (k=$K)\n\n";

###################################################################
}

#### subroutine not used
sub simple_sort {
    my($k) = $_[0];
    my(%distances) = %distance_pair;
    my($min_dist, $min_id);
    my(@top_k) = ();
## uses %distance_class_freq

    foreach $i (0..$k-1) {
	$min_dist = $big_num;
	foreach (@training_names) {
	    next unless defined $distances{$_};
	    if($distances{$_} < $min_dist) {
		$min_dist = $distances{$_};
		$min_id = $_;
	    } elsif(($distances{$_} == $min_dist) &&
		    ($training_class_freq{$LOCAT{ $_ }} <
		     $training_class_freq{$LOCAT{ $min_id }}) ) {
		$min_dist = $distances{$_};
		$min_id = $_;
	    }
	}
	push(@top_k, $min_id);
	delete $distances{$min_id};
    }
    @top_k
}
